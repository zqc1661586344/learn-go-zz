# go的pprof 

1. 用于诊断cpu占用过高、内存消耗大、goroutine泄露、以及阻塞等
- 使用net/http/pprof来启动一个服务，然后调用不同的url来进行分析
- 在runtime/pprof，使用这个包在具体业务代码执行的位置，然后将数据写入文件，再使用go tool pprof来查看

# slice切片相关

1. 引用类型，共享底层数据结构，当赋值给别的变量或传递给函数时复制的是header，并不会复制底层数据
    ```
    type slice struct {
        array unsafe.Pointer // 指向底层数组的指针
        len   int            // 切片的长度（当前实际存在的元素个数）
        cap   int            // 切片的容量（可以容纳的元素个数）
    }
    ```

2. 扩容机制
- go 1.17之前：
  - 容量<1024:新容量=旧容量 * 2
  - 容量>1024：新容量=旧容量 + 旧容量/4

- go 1.18之后：
  - 设定256为cap
  - 容量<256：新容量=旧容量 * 2
  - 容量>256：新容量=旧容量 + (旧容量 + 3*256)/4
  
3. 多个slice共享底层数组，修改一个会影响其他的；合理设置容量会减少扩容次数；扩容时会复制数据所以会影响性能；使用copy可以进行深拷贝


# sync相关

1. sync.Mutex
- 互斥锁。保证同一时刻只有一个 goroutine 访问共享资源。	保护一个变量或一段临界区代码的读写安全。发生数据竟态时使用
2. sync.RWMutex	
- 读写互斥锁。允许多个读并发，但写时独占。	读多写少的共享数据场景，可大幅提升读性能。
3. sync.WaitGroup	
- 等待组。用于等待一组 goroutine 完成任务。	主 goroutine 需要等待所有工作 goroutine 结束后再继续
- 里面有Add(),Done(),Wait()
4. sync.Once	
- 执行一次。保证某个函数在并发环境中只被执行一次。	延迟初始化（如单例模式）、配置加载，线程安全且高效。
5. sync.Pool	
- 临时对象池。缓存可复用的临时对象，减轻 GC 压力。	高频创建和销毁昂贵对象（如缓冲区、大结构体）的场景。
6. sync.Map	
- 并发安全map。为特定场景优化的并发安全 map。	适用于读多写极少或键值对基本不变化的场景。
7. sync.Cond	
- 条件变量。用于 goroutine 间的等待和通知。	复杂条件下，让 goroutine 阻塞等待某个信号或条件成立。
8. sync/atomic	
- 原子操作包。提供对基础类型的原子读、写、修改操作。	对简单类型的
  
# map的底层结构
1. 底层是一个哈希表，由两个核心组成，hmap（map头部结构，存储哈希表的元信息）和bmap（桶结构，存储键值对，默认可以存储8个键值对）
2. 为啥在用for循环遍历时是无序的？
- 故意设计为无序的，防止开发者依赖遍历顺序，其原因是哈希表的的特性：map通过哈希函数将特定的key存入到桶结构中，这个过程是无序的
- 遍历的起点是随机的，并不是每次都从第一个开始
- 扩容时会打乱顺序
3. 如何进行map的有序遍历？
- 先将key排序后再遍历
4. map访问流程
- 计算哈希值：用 hmap.hash0（随机种子）+ key 计算出哈希值 hash；
- 定位桶索引：取 hash 的低 B 位（如 B=3 → 低 3 位），确定该 key 属于桶数组中的第几个桶；
- 匹配键：取 hash 的高 8 位，与桶内 tophash 数组对比，找到匹配的位置；
- 存储/读取：若找到匹配的 tophash，直接操作对应位置的 key/value；若没找到，遍历溢出桶；若桶满且无匹配，新建溢出桶存储。


# string字符串相关
1. 底层结构如下
    ```
    // runtime/string.go
    type stringStruct struct {
        str unsafe.Pointer // 指向底层只读字节数组的指针（存储字符串的 UTF-8 编码字节）
        len int            // 字符串的字节长度（注意：不是字符数）
    }
    ```
2. 重要特性
- 不可变性，一旦创建不可修改，拼接和替换都是创建新的字符串
- 底层是只读的字节序列
- string和byte转换：string([]byte{})和[]byte(string)，都会涉及内存分配和复制
- 修改字符串需要先转换为rune切片或者byte切片
- 涉及大量字符串拼接请使用strings.Builder。
   ```go
   var builder strings.Builder
   for i := 0; i < 1000; i++ {
      // 如果使用+拼接则每次都会涉及重新分配内存
      builder.WriteString("a")
   }
   s := builder.String()
   ```
3. 注意字节遍历和字符遍历
- 使用`for i:=0; i<len(s);i++`这种形式获取的是字节(byte)遍历，如果有非Ascii字符会有问题
- 使用`for i,r := range s`这种形式得到的是“字符”(rune)

4. 相关问题

- 字符串为什么不可变？有何好处？
  - 安全性。防止意外修改共享字符串内容
  - 并发安全。多个goroutine可以同时读取一个字符串而无需加锁
  - 内存优化。允许字符串常量在编译期间确定并复用
  - 可作为哈希表（map）的 key（不可变性保证哈希值稳定）
  - 忽略大小写比较：需用strings.EqualFold(s1, s2)

- strings.Builder为何比+更高效？
  - 底层封装了[]byte，拼接时直接向[]byte追加，避免每次创建新的string
  - 支持预分配内存，减少[]byte扩容次数，仅最后在转化为string时进行内存拷贝


# goroutine相关

1. 底层结构

- 本质为go的轻量级并发执行单元，由go运行时（runtime）管理（runtime/runtime2.go）， “不要通过共享内存通信，而要通过通信共享内存”
   ```go
   type g struct {
      stack       stack   // 栈：包含栈底（lo）和栈顶（hi），动态扩缩
      m           *m      // 绑定的系统线程（M），运行时才非nil
      sched       gobuf   // 调度上下文：保存程序计数器（pc）、栈指针（sp）等，用于上下文切换
      status      uint32  // 状态：_Gidle（空闲）、_Grunnable（就绪）、_Grunning（运行）、_Gwaiting（阻塞）等
      goid        int64   // goroutine ID（运行时私有，无官方API获取）
      ctx         uintptr // 上下文指针，用于传递取消信号（如context）
      // 其他字段：栈缓存、等待原因、计时器等
   }
   ```
   - stack：goroutine初始栈2k，栈满自动扩容，栈空自动缩容
   - status：调度器判断goroutine是否可以调用的依据
   - goid：不可通过官方手段获取（主要是不想让开发者通过goid来控制goroutine，鼓励通过channel或context控制goroutine）

- 调度器基于GMP调度模型
  - G(goroutine)：go的轻量级线程。程序的基本执行单位
  - P(processor)：逻辑处理器。负责goroutine的队列和调度，（P的数量=GOMAXPROCS，默认=CPU核心数）
  - M(machine)：操作系统线程。执行真正的代码

- GMP的工作流程
  - 初始化：启动go程序，运行时创建GOMAXPROCS个P和若干个M
  - G创建：一个goroutine（G）被创建后（运行时执行go func()创建），被分配到当前P的本地G队列，如果满了则放入全局的G队列
  - M绑定P：如果M想要执行G，必须先绑定一个P
  - G执行：P会从队列中选择goroutine分配给M执行，如果本地为空，则从全局的队列获取，或者从其他P的队列中获取（work stealing机制） 
  - 阻塞处理：当M阻塞时，P会将G给其他的空闲的M执行
  - 调度抢占：P和M是动态绑定的，可随时调整。go1.14之前是协作式调度（G长时间计算会霸占M）；go1.14以后是异步调度，由运行时计时器检测如果占用M超过10ms，则会触发信号，让G让出cpu
  - 退出回收：G执行完毕会被放入G池，防止频繁创建

1. 相关问题

- goroutine和线程的区别？
  - 线程由操作系统创建，内核态线程，创建和切换开销大（切换成本为us），通常为几千个，单个线程启动时占内存大约为1M
  - goroutine由go运行时管理，用户态线程，创建和开销小（切换成本为几百ns），可达百万，单个goroutine启动时为2k（最大为1G），协作式调度，在遇到（函数调用、channel 操作、time.Sleep）时主动出让cpu

- 如何优雅关闭goroutine？
  - 使用context传递取消信号
  - 在goroutine中检查context.Done()
  - 使用select配合dedault避免阻塞  

- goroutine为何会泄漏？如何避免？
  - goroutine未正确退出，导致泄漏
  - 使用context控制生命周期；使用waitgrop确保退出；限制并发数量

- 为何goroutine栈的初始大小为2kb？
  - 避免浪费内存，会自动增长以满足大多数需求

- goroutine的调度时机是什么？
  - 主动挂起：主动让出，阻塞时
  - 被动调度：GC时（STW阶段）
  - 系统调用：进入系统调用前，P可能于M解绑；系统调用返回后，G尝试获取P执行

- work stealing（工作窃取）和hand off（交接）分别是什么？
  - work stealing：当P的本地队列为空时。从全局队列获取一批G（最多一半）；从其他P的本地队列获取一半G  
  - hand off：当G阻塞时（如系统调用）。M和P解绑；P寻找空闲的M或创建新的M；阻塞的G恢复后，尝试获取P的执行

- 如何排查goroutine泄漏？
  - 使用pprof，有个接口（/debug/pprof/goroutine?debug=1）
  - 使用runtime.NumGoroutine()
  - 使用gops工具

- goroutine太多有什么问题？
  - 内存消耗：每个goroutine至少2kb内存
  - 调度开销：goroutine切换消耗cpu
  - GC压力：增加GC负担
  - 竞争加剧：竞争共享资源

- 手写一个生产者和消费者模式

- 如何强制终止goroutine？
  - go没有官方方式强制杀掉goroutine，因为可能会导致资源泄漏，推荐使用channel/context来退出

-  goroutine泄漏
  - goroutine进入永久阻塞（无缓冲通道只发不收、只收不发、 select没有default且其他case未就绪、死循环），导致goroutine无法退出，占用内存和资源

- 百万级的goroutine场景如何进行性能优化？
  - goroutine：减少goroutine频繁创建开销，使用goroutine池（ants库）
  - channel：使用有缓冲通道，减少同步开销
  - 控制GOMAXPROCS：IO密集型可调大，cpu密集型保持默认
  - 避免锁竞争：使用读写锁替代互斥锁
  - 监控调度状态：通过runtime/pprof监控goroutine的阻塞、运行、调度等

- 竟态条件如何检测和解决？
  - 竟态条件：多个goroutine同时读写共享变量，导致相关问题
  - 检测：运行时加-race参数（go run -race）会自动检测
  - 解决：（1）使用channel传递数据；（2）使用锁；（3）使用atomic原子操作

# 锁机制

1. 以核心sync.Mutex为例，基于runtime层面优化
   ```go
   type Mutex struct {
      state int32 // 锁状态：0=未锁，1=已锁，2=等待锁的goroutine
      sema  uint32 // 信号量（用于阻塞和唤醒goroutine）
   }
   ```
- 上述state为32位无符号整数，其中各位置表示的含义如下
  - 第0位，locked（锁定），如果是1表示被持有，0表示锁空
  - 第1位，woken（唤醒），如果是1表示有goroutine被唤醒，避免重复唤醒
  - 第2位，starvation（饥饿），如果是1表示进入饥饿模式，0表示正常模式
  - 第3-31位，waitersCount（等待计数）， 等待获取锁的goroutine数量（大约20亿）

- 核心模式
  - 正常模式（默认）：非公平锁。新到来的锁先进入自旋模式尝试获取锁，如果失败了，进入等待队列；被唤醒的goroutine与新的goroutine竞争，可能导致老的goroutine进入饥饿
  - 饥饿模式：go1.9引入，当一个goroutine超过1ms未获取锁，则进入饥饿模式，此时锁直接交给等待队列头部的goroutine，当等待队列为空或持有锁的goroutine时最后一个则退出饥饿模式。引入饥饿模式主要为平衡“性能”和“公平性”

2. 锁的工作原理
- 尝试获取锁：使用Lock加锁时检查state是否为0
- 自旋等待：锁被占用，则自旋等待（短暂的）
- 阻塞等待：自旋失败，则进入等待队列（sema信号量控制）
- 释放：Unlock时唤醒等待队列中的goroutine