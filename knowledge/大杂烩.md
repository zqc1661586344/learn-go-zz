# go的pprof 
用于诊断cpu占用过高、内存消耗大、goroutine泄露、以及阻塞等
1. 使用net/http/pprof来启动一个服务，然后调用不同的url来进行分析
2. 在runtime/pprof，使用这个包在具体业务代码执行的位置，然后将数据写入文件，再使用go tool pprof来查看

# slice切片相关
1. 引用类型，共享底层数据结构，当赋值给别的变量或传递给函数时复制的是header，并不会复制底层数据
    ```
    type slice struct {
        array unsafe.Pointer // 指向底层数组的指针
        len   int            // 切片的长度（当前实际存在的元素个数）
        cap   int            // 切片的容量（可以容纳的元素个数）
    }
    ```

2. 扩容机制   
- go 1.17之前：
  - 容量<1024:新容量=旧容量 * 2
  - 容量>1024：新容量=旧容量 + 旧容量/4

- go 1.18之后：
  - 设定256为cap
  - 容量<256：新容量=旧容量 * 2
  - 容量>256：新容量=旧容量 + (旧容量 + 3*256)/4

3. 多个slice共享底层数组，修改一个会影响其他的；合理设置容量会减少扩容次数；扩容时会复制数据所以会影响性能；使用copy可以进行深拷贝


# sync相关
1. sync.Mutex
   - 互斥锁。保证同一时刻只有一个 goroutine 访问共享资源。	保护一个变量或一段临界区代码的读写安全。发生数据竟态时使用
2. sync.RWMutex	
   - 读写互斥锁。允许多个读并发，但写时独占。	读多写少的共享数据场景，可大幅提升读性能。
3. sync.WaitGroup	
   - 等待组。用于等待一组 goroutine 完成任务。	主 goroutine 需要等待所有工作 goroutine 结束后再继续
   - 里面有Add(),Done(),Wait()
4. sync.Once	
   - 执行一次。保证某个函数在并发环境中只被执行一次。	延迟初始化（如单例模式）、配置加载，线程安全且高效。
5. sync.Pool	
   - 临时对象池。缓存可复用的临时对象，减轻 GC 压力。	高频创建和销毁昂贵对象（如缓冲区、大结构体）的场景。
6. sync.Map	
   - 并发安全map。为特定场景优化的并发安全 map。	适用于读多写极少或键值对基本不变化的场景。
7. sync.Cond	
   - 条件变量。用于 goroutine 间的等待和通知。	复杂条件下，让 goroutine 阻塞等待某个信号或条件成立。
8. sync/atomic	
   - 原子操作包。提供对基础类型的原子读、写、修改操作。	对简单类型的
  
# map的底层结构
1. 底层是一个哈希表，由两个核心组成，hmap（map头部结构，存储哈希表的元信息）和bmap（桶结构，存储键值对，默认可以存储8个键值对）
2. 为啥在用for循环遍历时是无序的？
   - 故意设计为无序的，防止开发者依赖遍历顺序，其原因是哈希表的的特性：map通过哈希函数将特定的key存入到桶结构中，这个过程是无序的
   - 遍历的起点是随机的，并不是每次都从第一个开始
   - 扩容时会打乱顺序
3. 如何进行map的有序遍历？
   - 先将key排序后再遍历
4. map访问流程
   - 计算哈希值：用 hmap.hash0（随机种子）+ key 计算出哈希值 hash；
   - 定位桶索引：取 hash 的低 B 位（如 B=3 → 低 3 位），确定该 key 属于桶数组中的第几个桶；
   - 匹配键：取 hash 的高 8 位，与桶内 tophash 数组对比，找到匹配的位置；
   - 存储/读取：若找到匹配的 tophash，直接操作对应位置的 key/value；若没找到，遍历溢出桶；若桶满且无匹配，新建溢出桶存储。


# string字符串相关
1. 底层结构如下
    ```
    // runtime/string.go
    type stringStruct struct {
        str unsafe.Pointer // 指向底层只读字节数组的指针（存储字符串的 UTF-8 编码字节）
        len int            // 字符串的字节长度（注意：不是字符数）
    }
    ```
2. 重要特性
   - 不可变性，一旦创建不可修改，拼接和替换都是创建新的字符串
   - 是字节序列
   - string和byte转换：string([]byte{})和[]byte(string)，都会涉及内存分配和复制
3. 注意字节遍历和字符遍历 
